# Реализуйте алгоритм быстрой сортировки (её называют сортировкой Хоара).
#
# За один шаг алгоритма выполните следующие действия:
#
# Выберите один элемент списка (его иногда называют опорным элементом).
# Сделать это можно разными способами, но важно придерживаться одного принципа.
# В нашем случае опорным элементом всегда будет крайний правый (например, в списке [1, 2, 3] это 3).

# Разбейте текущий список на три части: элементы меньше опорного, равные опорному и больше опорного.
# В списке [5, 8, 9, 4, 2, 9, 1, 8] опорным элементом будет число 8 (крайнее правое), а получить надо три списка:
# [5, 4, 2, 1];
# [8, 8];
# [9, 9].

# Для списка с элементами меньше опорного ([5, 4, 2, 1]) и списка с элементами больше опорного ([9, 9]) выполните
# те же шаги заново — запустите рекурсию.
# результат_1 = рекурсия([5, 4, 2, 1]).
# результат_2 = [8, 8].
# результат_3 = рекурсия([9, 9]).

# Сложите результаты вызова рекурсий и получите отсортированный список:
# отсортированный_список = результат_1 + результат_2 + результат_3.

def quick_sort(nums):
    if len(nums) < 1: return []
    sep_elm = nums[-1]
    less_sep = []
    equal_sep = []
    more_sep = []
    for num in nums:
        if num < sep_elm: less_sep.append(num)
        elif num == sep_elm: equal_sep.append(num)
        else: more_sep.append(num)

    return quick_sort(less_sep) + equal_sep + quick_sort(more_sep)


nums = [5, 8, 9, 4, 2, 9, 1, 8]

print(quick_sort(nums))